.蓝桥杯2020年真题

## 美丽的数字2
```
count = 0
for i in range(1,2021):
    strs = list(str(i))
    if "2" in strs:
        count+=1

print(count)
```

## 合数个数
* 定义判断素数的函数
```
import math
def is_prime(n):
    sqrt = int(math.sqrt(n))

    for i in range(2,sqrt+1):
        if n%i==0:
            return False
    
    return True

count = 0

for i in range(2,2021):
    if is_prime(i):
        count+=1
    

print(2019-count)
```
## 天干地支
* 关键是推出公元1年的年份
```
t = ["","xin","ren","gui","jia","yi","bing","ding","wu","ji","geng"]
d = ["","you","xu","hai","zi","chou","yin","mao","chen","si","wu","wei","shen"]

n = int(input())

a = n%10
if a==0:
    a=10
b = n%12

print(t[a]+d[b])
```

## 阶乘约数
* 题目想求100！有多少个约数。正确答案是：39001250856960000  以下为解答：
* 理论依据为唯一分解定理:一个大于1的正整数N，如果它的标准分解式为：(p1^a1)*(p2^a2)*...*(pn^an) ，那么它的正因数个数为 result = (1+a1)*(1+a2)*...*(1+an),其中p1到pn均为素数。也就是说任意大于1的正整数都可表示为素数的组合
```
p=[1]*100
dp = []
def is_prime(n):
    for i in range(2,n):
        if n%i==0:
            return False
    return True

def add_prime(n):
    if is_prime(n):
        dp.append(n)

for i in range(2,101):
    add_prime(i)

listindex = [0]*len(dp)
for i in range(2,101):
    for j in range(len(dp)):
        m = i
        while m%dp[j] == 0:
            listindex[j]+=1
            m = m//dp[j]

result = 1
for j in listindex:
    result *= (j+1)

print(result)
```

## 本质上升序列
* 动态规划思想
* python读取文件格式 f.read("文件地址","r或者w")  strs = f.read()  f.close()
```
#可以用数字串来模拟，方便思考

#读取文件中的字符串
f=open("./1.txt","r+")
strs = f.read()
f.close()

n = len(strs)

dp = [1]*n#定义一个保存上升序列个数的数组。因为每个字符都可当做上升序列，因此初始值为1

#动态规划思想
for i in range(n):
    for j in range(i):
        if strs[i]>strs[j]:
            dp[i]+=dp[j]
        elif strs[i] == strs[j]:
            dp[i]-=dp[j]

result = 0
for i in dp:
    result+=i
print(result)
```



## 贪吃蛇
* DFS深度搜索
* 递归
* isVisited = [[False for _ in range(4)] for _ in range(4)]这句话表示构建一个4行4列的bool型列表
```
#动态规划函数
def dfs(i,j,step):
    global count,isVisited
    if step == 16:
        count+=1
        return
    
    for k in range(4):
        ii = i+d[k][0]
        jj = j+d[k][1]
        if ii>=0 and ii<=3 and jj>=0 and jj<=3 and isVisited[ii][jj] == False:
            isVisited[ii][jj]=True
            dfs(ii,jj,step+1)
            isVisited[ii][jj]=False #回溯：一个点可有多个父节点，也就是玩具蛇有多种放置方式

count = 0
d = [(-1,0),(1,0),(0,1),(0,-1)]

for i in range(4):
    for j in range(4):
        isVisited = [[False for _ in range(4)] for _ in range(4)] #在这里开始一个新的放置方式序列，每个序列的起点相同，但是放置方式不同。因此需要定义新的visit标志
        isVisited[i][j] = True
        dfs(i,j,1)

print(count)
```

## 重复字符串
* 这破题算的人头疼
* 实际上根据题目要求，将字符串划分为n行m列。然后看每一列哪个元素出现的最多记其次数为a，用m-a代表该列需要修改元素的个数。然后将每列需修改数加起来，就是结果
* 若字符串长度%n！=0  输出-1
```
n = int(input())
strs = input()

s1 = ""
c = 0
m = len(strs)//n
if len(strs)%n!=0:
    print(-1)

else:
    for i in range(m):
        d = []
        for j in range(n):
            s1+=strs[i+j*m]
        print(s1,end=' ')
        for a in s1:
            d.append(a)
        print(d,end=' ')
        s1 = ""
        
        dic = {}
        for key in d:
            dic[key] = dic.get(key,0)+1

        print(dic)

        print(max(dic.values()))
        c+=(n-max(dic.values()))
        
    print(c)
            
```

## 答疑
* 贪心算法
* 关键是最后两部。
```
n = int(input())
time = []
for i in range(n):
    time.append(list(map(int,input().split())))


r = []

for i in range(n):
    r.append([sum(time[i]),time[i][2]])

r.sort()

result = 0
temp = 0
for i in range(n):
    result += r[i][0]-r[i][1]+temp
    temp += r[i][0]

print(result)

```
